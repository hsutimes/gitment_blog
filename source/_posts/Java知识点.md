---
title: Java知识点
tags:
  - Java
categories:
  - 文章
toc: false
date: 2019-09-20 10:24:00
---

# Java相关

## 请问JDK和JRE的区别是什么？

> JDK ：Java 开发工具包,jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。
JRE ：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。

## springboot的注解有什么，原理？

@Bean
用来代替 XML 配置文件里面的 <bean ...> 配置。
@ImportResource
如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 @Configuration 方式配置的非常管用。
@Import
用来引入额外的一个或者多个 @Configuration 修饰的配置文件类。
@SpringBootConfiguration
这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。
@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。
@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。
@EnableAutoConfiguration 自动配置。
@ComponentScan 组件扫描，可自动发现和装配一些Bean。
@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。
@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。
@Autowired自动导入。
@PathVariable获取参数。
@JsonBackReference解决嵌套外链问题。
@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。

@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。
用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：
params:指定request中必须包含某些参数值是，才让该方法处理。
headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。
value:指定请求的实际地址，指定的地址可以是URI Template 模式
method:指定请求的method类型， GET、POST、PUT、DELETE等
consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;
produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回

@RequestParam：用在方法的参数前面。
@RequestParam
String a =request.getParameter(“a”)。

@PathVariable:路径变量。如
```java
@RequestMapping(“user/get/mac/{macAddress}”) 
public String getByMacAddress(@PathVariable String macAddress){ 
//do something; 
} 
```

Spring Boot的自动配置看起来神奇，其实原理非常简单，背后全依赖于@Conditional注解来实现的。

## object类中的hashCode（）方法是做什么的，以及其中的hash（）方法是做什么的， 为什么有hash（）方法还有hashCode（）

哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:

```java
public native int hashCode();
```

根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。

**hashCode方法的作用**

对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。

　　为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）

　　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。

**hash 算法**
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。

如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。

但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。

总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。

## hashmap的put过程 主要就是根据自己看过的源码说一下流程

**put 方法**
通过 hash 计算下标并检查 hash 是否冲突，也就是对应的下标是否已存在元素。
```java
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```
1. 判断数组是否为空，如果是空，则创建默认长度位 16 的数组。
2. 通过与运算计算对应 hash 值的下标，如果对应下标的位置没有元素，则直接创建一个。
3. 如果有元素，说明 hash 冲突了，则再次进行 3 种判断。
    1. 判断两个冲突的key是否相等，equals 方法的价值在这里体现了。如果相等，则将已经存在的值赋给变量e。最后更新e的value，也就是替换操作。
    2. 如果key不相等，则判断是否是红黑树类型，如果是红黑树，则交给红黑树追加此元素。
    3. 如果key既不相等，也不是红黑树，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果，链表的长度大于等于8了，则将链表改为红黑树，这是Java8 的一个新的优化。
4. 最后，如果这三个判断返回的 e 不为null，则说明key重复，则更新key对应的value的值。
5. 对维护着迭代器的modCount 变量加一。
6. 最后判断，如果当前数组的长度已经大于阀值了。则重新hash。


## ArrayList LinkList的特点

ArrayList是实现了基于动态数组的结构，LinkedList则是基于实现链表的数据结构。

数据的更新和查找
ArrayList的所有数据是在同一个地址上,而LinkedList的每个数据都拥有自己的地址.所以在对数据进行查找的时候，由于LinkedList的每个数据地址不一样，get数据的时候ArrayList的速度会优于LinkedList，而更新数据的时候，虽然都是通过循环循环到指定节点修改数据，但LinkedList的查询速度已经是慢的，而且对于LinkedList而言，更新数据时不像ArrayList只需要找到对应下标更新就好，LinkedList需要修改指针，速率不言而喻

数据的增加和删除
对于数据的增加元素，ArrayList是通过移动该元素之后的元素位置，其后元素位置全部+1，所以耗时较长，而LinkedList只需要将该元素前的后续指针指向该元素并将该元素的后续指针指向之后的元素即可。与增加相同，删除元素时ArrayList需要将被删除元素之后的元素位置-1，而LinkedList只需要将之后的元素前置指针指向前一元素，前一元素的指针指向后一元素即可。当然，事实上，若是单一元素的增删，尤其是在List末端增删一个元素，二者效率不相上下。

## 红黑树定义

红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。

由于 TreeMap 就是由红黑树实现的。

黑色高度
从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。

1. 每个节点要么是红色，要么是黑色；
2. 根节点永远是黑色的；
3. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
4. 每个红色节点的两个子节点一定都是黑色；
5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

## Java 反射机制

Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 **动态的获取信息** 以及 **动态调用对象的方法** 的功能称为 java 的反射机制。


```java
public class FatherClass {
    public String mFatherName;
    public int mFatherAge;

    public void printFatherMsg(){}
}
```


# 多线程相关

## synchronized

synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。

锁机制有如下两种特性：

- 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。

- 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。

synchronized 可以修饰方法和代码块

- synchronized(this|object) {}
- synchronized(类.class) {}
- 修饰非静态方法
- 修饰静态方法

## reentrantLock 除了可重入还有什么关键特性

- 可重入

现在有方法 m1 和 m2，两个方法均使用了同一把锁对方法进行同步控制，同时方法 m1 会调用 m2。线程 t 进入方法 m1 成功获得了锁，此时线程 t 要在没有释放锁的情况下，调用 m2 方法。由于 m1 和 m2 使用的是同一把可重入锁，所以线程 t 可以进入方法 m2，并再次获得锁，而不会被阻塞住。

- 公平和非公平锁

公平与非公平指的是线程获取锁的方式。公平模式下，线程在同步队列中通过 FIFO 的方式获取锁，每个线程最终都能获取锁。在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 使用的是非公平模式获取锁，而不是公平模式。不过我们也可通过 ReentrantLock 构造方法ReentrantLock(boolean fair)调整加锁的模式。

## ThreadLocal 会造成什么问题? 为什么会造成内存泄漏?

- ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型。 总结：ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。 
- ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。

ThreadLocal类提供了四个对外开放的接口方法

(1) void set(Object value)设置当前线程的线程局部变量的值。 
(2) public Object get()该方法返回当前线程所对应的线程局部变量。  
(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用。
(4) protected Object initialValue()返回该线程局部变量的初始值。

在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。

最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。**比如使用线程池的时候，线程结束是不会销毁的，会再次使用的就可能出现内存泄露。**（在web应用中，每次http请求都是一个线程，tomcat容器配置使用线程池时会出现内存泄漏问题）

1. 使用ThreadLocal，建议用static修饰 static ThreadLocal<HttpHeader> headerLocal = new ThreadLocal();
2. 使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。

## 单例模式 synchronized实现懒汉模式？为什么用内部类是线程安全的？

内部类

单例模式，有“懒汉式”和“饿汉式”两种。
**懒汉式**
单例类的实例在第一次被引用时候才被初始化。
**饿汉式**
单例类的实例在加载的时候就被初始化。

**静态内部类模式**
```java
public class Singleton { 
    private Singleton(){
    }
      public static Singleton getSingleton(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
```

1. 实现代码简洁。和双重检查单例对比，静态内部类单例实现代码真的是太简洁，又清晰明了。
2. 延迟初始化。调用getSingleton才初始化Singleton对象。
3. 线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。

线程A和线程B同时试图获得Singleton对象的初始化锁，假设线程A获取到了，那么线程B一直等待初始化锁。线程A执行类初始化，就算双重检查模式中伪代码发生了重排序，也不会影响线程A的初始化结果。初始化完后，释放锁。线程B获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。

# 数据库相关

## 添加索引的时候要注意什么

索引可以提高数据的访问速度，但同时也增加了插入、更新和删除操作的处理时间。所以是否要为表增加索引、索引建立在那些字段上，是创建索引前必须要考虑的问题。解决此问题就是分析应用程序的业务处理、数据使用，为经常被用作查询条件、或者被要求排序的字段建立索引。

1、表的主键、外键必须有索引；
2、数据量超过300的表应该有索引；
3、经常与其他表进行连接的表，在连接字段上应该建立索引；
4、经常出现在`Where`子句中的**字段**，特别是大表的字段，应该建立索引；
5、索引应该建在选择性高的字段上；
6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7、复合索引的建立需要进行仔细分析；

**聚簇索引:**
通常由主键或者非空唯一索引实现的，叶子节点存储了一整行数据
**非聚簇索引：**
又称二级索引，就是我们常用的普通索引，叶子节点存了索引值和主键值，在根据主键从聚簇索引查

## 索引优化以及在使用索引的时候要注意什么

1.索引列不要使用函数和运算
2. 尽量避免使用 != 或 not in或 <> 等否定操作符
3.当查询条件为多个的时候，可以采用复合索引
4.范围查询对多列查询的影响
5.遵循最左匹配原则
   复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。
6.索引列不会包含NULL值
7.尽量避免使用 or 来连接条件
8.隐式转换的影响
9.like 语句的索引失效问题

## redis的键的淘汰策略，会达成了redis缓存的淘汰策略

Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。
事实上，实例中的内存除了保存原始的键值对所需的开销外，还有一些运行时产生的额外内存，包括：

1. 垃圾数据和过期Key所占空间
2. 字典渐进式Rehash导致未及时删除的空间
3. Redis管理数据，包括底层数据结构开销，客户端信息，读写缓冲区等
4. 主从复制，bgsave时的额外开销

为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。
- 访问Key时，会判断Key是否过期，逐出过期Key;
- CPU空闲时在定期serverCron任务中，逐出部分过期Key;
- 每次事件循环执行的时候，逐出部分过期Key;


# 网络相关

## tcp四次握手，最后的状态是什么?

等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2）

## 为什么要等着2MSL，等待多了会造成什么

1. 保证A发送的最后一个ACK报文段能够到达B。
2. 防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## http请求的报文结构，keep-alive是用来做什么的

当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

```shell
Keep-Alive: timeout=5, max=100
timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接
```

# spring spingboot

## spring为什么要注入接口，而不是实现类

首先说明，注入的对象确实为实现类的对象。（并不是实现类的代理对象，注入并不涉及代理）

　　如果只是单纯注入是可以用实现类接收注入对象的，但是往往开发中会对实现类做增强，如事务，日志等，实现增强的AOP技术是通过动态代理实现的，而spring默认是JDK动态代理，对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。

回答没听过这个概念，然后被引导回到IOC和AOP，以及AOP是什么，实现过程

Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果目标对象没有实现接口我们该如何代理呢？这时候我们就需要使用CGLIB来实现AOP了。

假如我们要使用动态代理实现AOP，那么我们只能在写一个增强的接口，然后让目标类实现增强接口，然后我们就可以使用动态代理实现目标类的增强，可是假如我们不想让目标类实现其他的接口，那么我们就只能使用CGLIB技术来实现目标类的增强了。
CGLIB实现目标类增强的原理是这样的：CGLIB会动态创建一个目标类的子类，然后返回该子类的对象，也就是增强对象，至于增强的逻辑则是在子类中完成的。我们知道子类要么和父类有一样的功能，要么就比父类功能强大，所以CGLIB是通过创建目标类的子类对象来实现增强的，所以：

```shell
目标子类 = 目标类 + 增强逻辑
```

# 口述算法思路

## 给一个栈的数据结构，实现另外一个数据结构，要求保留栈的特性，同时能够提供去最大值和最小值的方法，时间复杂度为O（1）

最小值思路：用一个辅助栈stack2记住每次入栈stack1的当前最小值:在stack1入栈时，往stack2中加入当前最小值；stack1元素出栈时，stack2也出栈一个元素。最小值从stack2中获取及栈顶元素。O(1)

最大值思路：同上O(1)

![image.png](/images/2019/09/20/e4dc2930-db6e-11e9-a4dc-99db33a3ba56.png)

# 网络编程

## 哪几种IO类型

- 阻塞I/O（blocking IO）
- 非阻塞I/O (nonblocking I/O)
- I/O 复用 (I/O multiplexing)
- 信号驱动I/O (signal driven I/O (SIGIO))
- 异步I/O (asynchronous I/O)


# JVM

## JVM的内存结构

- 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。
- 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。
- 方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。
- 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
- 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。

![image.png](/images/2019/09/20/801edd70-db6f-11e9-a4dc-99db33a3ba56.png)


## 类加载机制

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*
Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。

![image.png](/images/2019/09/20/96bb2250-db6f-11e9-a4dc-99db33a3ba56.png)

## 双亲委派模型

双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。

双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。

# 有什么想问我的

有的

1. 你怎样形容小米公司的企业文化？
2. 什么类型的员工能在小米公司有比较好的发展？
3. 关于软件开发工程师-Java方向岗位的技术栈、日常主要工作是什么、期间可以获得晋升机会？
4. 能给我多讲讲招聘程序吗？
5. 我没有其他问题了，与您交流非常愉快，能留一张您的名片么？（或者方便加一下您的微信么？）